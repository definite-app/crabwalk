use anyhow::Result;
use std::collections::HashMap;
use std::fs;
use std::path::Path;

use crate::parser::dependencies::Dependency;

/// Generate an XML schema from the database
pub fn generate_database_schema(
    dependencies: &HashMap<String, Dependency>,
    output_path: &str,
) -> Result<()> {
    // Create base XML structure
    let mut xml = String::new();
    xml.push_str("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    xml.push_str("<database name=\"crabwalk_database\">\n");
    xml.push_str("  <description>\n");
    xml.push_str("    Database schema generated by Crabwalk. This schema represents the structure of tables\n");
    xml.push_str("    derived from SQL transformations, including dependencies and relationships.\n");
    xml.push_str("  </description>\n");
    
    // Generate schemas section
    add_schemas_section(&mut xml, dependencies)?;
    
    // Generate relationships section
    add_relationships_section(&mut xml, dependencies)?;
    
    // Generate lineage section
    add_lineage_section(&mut xml, dependencies)?;
    
    // Close the XML
    xml.push_str("</database>");
    
    // Write to file
    let output_dir = Path::new(output_path).parent().unwrap_or(Path::new("."));
    fs::create_dir_all(output_dir)?;
    fs::write(output_path, xml)?;
    
    tracing::info!("Generated database schema at {}", output_path);
    
    Ok(())
}

/// Add schemas section to the XML
fn add_schemas_section(xml: &mut String, dependencies: &HashMap<String, Dependency>) -> Result<()> {
    xml.push_str("  <!-- Tables derived from SQL transformations -->\n");
    xml.push_str("  <schema name=\"transform\">\n");
    xml.push_str("    <description>Tables generated by Crabwalk transformations</description>\n");
    
    // Sort dependencies by name for consistent output
    let mut sorted_deps: Vec<(&String, &Dependency)> = dependencies.iter().collect();
    sorted_deps.sort_by_key(|a| a.0);
    
    for (table_name, dependency) in sorted_deps {
        xml.push_str(&format!("    <table name=\"{}\">\n", table_name));
        xml.push_str(&format!("      <description>Generated from {}</description>\n", dependency.filename));
        
        // Add inferred columns based on SQL if available
        // For now, we'll just add a placeholder
        xml.push_str("      <column name=\"id\" type=\"unknown\" primary_key=\"true\">\n");
        xml.push_str("        <description>Primary key (automatically inferred)</description>\n");
        xml.push_str("      </column>\n");
        
        // Add dependency information
        if !dependency.deps.is_empty() {
            xml.push_str("      <source_dependencies>\n");
            for dep in &dependency.deps {
                xml.push_str(&format!("        <dependency table=\"{}\" type=\"transformation\"/>\n", dep));
            }
            xml.push_str("      </source_dependencies>\n");
        }
        
        xml.push_str("    </table>\n");
    }
    
    xml.push_str("  </schema>\n");
    
    Ok(())
}

/// Add relationships section to the XML
fn add_relationships_section(xml: &mut String, dependencies: &HashMap<String, Dependency>) -> Result<()> {
    xml.push_str("  <!-- Entity-Relationship Diagram -->\n");
    xml.push_str("  <entity_relationships>\n");
    
    // For each dependency, create relationships based on dependencies
    for (table_name, dependency) in dependencies {
        for dep in &dependency.deps {
            // Only add relationships for known tables
            if dependencies.contains_key(dep) {
                xml.push_str(&format!("    <relationship type=\"references\" name=\"{}_to_{}\">\n", table_name, dep));
                xml.push_str(&format!("      <from table=\"transform.{}\" column=\"id\"/>\n", table_name));
                xml.push_str(&format!("      <to table=\"transform.{}\" column=\"id\"/>\n", dep));
                xml.push_str(&format!("      <description>{} depends on {}</description>\n", table_name, dep));
                xml.push_str("    </relationship>\n");
            }
        }
    }
    
    xml.push_str("  </entity_relationships>\n");
    
    Ok(())
}

/// Add lineage section to the XML
fn add_lineage_section(xml: &mut String, dependencies: &HashMap<String, Dependency>) -> Result<()> {
    xml.push_str("  <!-- Data Lineage -->\n");
    xml.push_str("  <data_lineage>\n");
    xml.push_str("    <transformation name=\"sql_transformations\">\n");
    xml.push_str("      <description>SQL-based data transformations executed by Crabwalk</description>\n");
    xml.push_str("      <steps>\n");
    
    // For each dependency, document the transformation
    for (table_name, dependency) in dependencies {
        if !dependency.deps.is_empty() {
            xml.push_str(&format!("        <step from=\"multiple\" to=\"transform.{}\">\n", table_name));
            xml.push_str("          <sources>\n");
            for dep in &dependency.deps {
                xml.push_str(&format!("            <source>{}</source>\n", dep));
            }
            xml.push_str("          </sources>\n");
            xml.push_str("          <operations>\n");
            xml.push_str("            <operation>SQL transformation</operation>\n");
            xml.push_str("          </operations>\n");
            xml.push_str("        </step>\n");
        } else {
            // For source tables with no dependencies
            xml.push_str(&format!("        <step from=\"source\" to=\"transform.{}\">\n", table_name));
            xml.push_str("          <operations>\n");
            xml.push_str("            <operation>Source data load</operation>\n");
            xml.push_str("          </operations>\n");
            xml.push_str("        </step>\n");
        }
    }
    
    xml.push_str("      </steps>\n");
    xml.push_str("    </transformation>\n");
    xml.push_str("  </data_lineage>\n");
    
    Ok(())
}